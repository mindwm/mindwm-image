---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mindwm-e2e-config
data:
  entrypoint.yaml: | 
    session_name: mindwm-terminal
    shell_command_before: 
      - set -e 
      - trap 'TITLE="`tmux display-message -p \#T` FAIL"; printf "\e]0;%s\e\\" "$TITLE"; sleep infinity' ERR
      - 'tmux set -g pane-border-format "#{pane_index} #{pane_title}"'
      - alias pane_title="printf '\e]0;%s\e\\'"
      - |
        test_pane_title() { 
          tmux_window=`tmux list-panes -a | grep " ${TMUX_PANE} "| cut -d: -f2`
          TITLE="TEST: $(tmux display-message -t ${tmux_window} -p '#W'): $*";
          printf '\e]0;%s\e\\' "${TITLE}";  
        }
      - |
        wait_for_state() {
          while :; do
            echo -n .
            tmux list-panes -a -F '#{pane_title}' | grep "$*" && break
            sleep 1
          done
        } 
      - 'tmux set -g pane-border-status bottom'
      - export MINDWM_E2E_PS1='root@mindwm-client:~tmp $'
      - export MINDWM_E2E_INPUT_CMD="echo ${MINDWM_UUID}"
      - export MINDWM_E2E_EXPECTED_OUTPUT="${MINDWM_UUID}"
      - export MINDWM_ASCIINEMA_REC_PIPE="/tmp/${MINDWM_UUID}.sock"
      - export MINDWM_TMUX=`echo -n ${TMUX} | base64`
      - export MINDWM_BACK_NATS_SUBJECT_PREFIX="mindwm.`whoami`.`hostname -s`.tmux.${MINDWM_TMUX}.${MINDWM_UUID}.0.0"
      - export MINDWM_BACK_NATS_PORT=4222
      - export MINDWM_BACK_NATS_HOST=nats.nats
      - export MINDWM_BACK_NATS_USER=root
      - export MINDWM_BACK_NATS_PASS=r00tpass
      - export NATS_URL=nats://${MINDWM_BACK_NATS_USER}:${MINDWM_BACK_NATS_PASS}@${MINDWM_BACK_NATS_HOST}:${MINDWM_BACK_NATS_PORT}
      - test_pane_title "start"
    windows:
      - window_name: prepare_env
        layout: main-horizontal
        panes:
          - shell_command:
              - |
                test_pane_title "generate host.yaml"
                cat<<EOF | yq | tee resources.yaml 
                ---
                apiVersion: serving.knative.dev/v1
                kind: Service
                metadata:
                  name: event-display-mindwm-e2e-test
                  namespace: context-${CONTEXT_NAME}
                spec:
                  template:
                    spec:
                      containers:
                      - env: []
                        image: gcr.io/knative-releases/knative.dev/eventing/cmd/event_display
                ---
                apiVersion: eventing.knative.dev/v1
                kind: Trigger
                metadata:
                  name: all-events-mindwm-e2e-test
                  namespace: context-${CONTEXT_NAME}
                spec:
                  broker: context-broker-${CONTEXT_NAME}
                  subscriber:
                    ref:
                      apiVersion: serving.knative.dev/v1
                      kind: Service
                      name: event-display-mindwm-e2e-test
                  delivery:
                    deadLetterSink:
                      ref:
                        apiVersion: serving.knative.dev/v1
                        kind: Service
                        name: event-display-mindwm-e2e-test
                ---
                apiVersion: mindwm.io/v1beta1
                kind: User
                metadata:
                  name: user
                spec:
                  context: [ "team-a" ]
                  name: "`whoami`"
                ---
                apiVersion: mindwm.io/v1beta1
                kind: Host
                metadata:
                  name: host-`hostname`
                spec:
                  name: "`hostname`"
                  username: "`whoami`"
                EOF
              - |
                test_pane_title "delete resources.yaml"
                kubectl delete -f resources.yaml || :
              - |
                test_pane_title "apply resources.yaml"
                kubectl apply -f resources.yaml
              - |
                test_pane_title "waiting for broker resource"
                while :; do
                  kubectl get natsjetstreamchannels.messaging.knative.dev -n user-`whoami` -l eventing.knative.dev/broker=`hostname`-broker | grep `hostname` || {
                    echo -n . 
                    sleep 1
                    continue
                  } 
                  break
                done
              - | 
                test_pane_title "waiting for user-broker"
                kubectl -n user-`whoami` wait --namespace user-`whoami` --for=condition=Ready --timeout=180s broker/user-`whoami`-broker
                test_pane_title "waiting for user -> context trigger"
                kubectl -n user-`whoami` wait --for=condition=READY=True --timeout=180s -n user-root trigger.eventing.knative.dev/trigger-user-broker-to-${CONTEXT_NAME}
              - | 
                test_pane_title "waiting for NatsJetStreamChannel is ready"
                kubectl -n user-`whoami` wait --namespace user-`whoami` --for=condition=Ready --timeout=180s NatsJetStreamChannel/`hostname`-broker-kne-trigger
                test_pane_title "waitiing for broker"
                kubectl -n user-`whoami` wait --namespace user-`whoami` --for=condition=Ready --timeout=180s broker/`hostname`-broker
                # Unknown ready status is okay, possible knative jetstream bug
                test_pane_title "waiting for trigger"
                kubectl -n user-`whoami` wait --for=condition=READY=Unknown --timeout=180s -n user-root trigger.eventing.knative.dev/trigger-host-broker-to-`hostname`
                # Funny, the issue opened on 20 Junl 2018 https://github.com/kubernetes/kubernetes/issues/66456 
                test_pane_title "waiting for subscription"
                kubectl -n user-`whoami` wait subscription --for=condition=READY=Unknown --timeout=5s -l eventing.knative.dev/trigger=trigger-host-broker-to-`hostname`
                test_pane_title "OK"
      - window_name: Fire event
        layout: main-horizontal
        panes:
          - shell_command:
              - |
                wait_for_state "TEST: prepare_env: OK"
                test_pane_title "waiting for nats subscriber"
                while :; do 
                  pgrep -f "nats -s ${NATS_URL} sub -r ${MINDWM_BACK_NATS_SUBJECT_PREFIX}.iodocument --count 1" || {
                    echo -n .
                    sleep 1
                  } && break
                done
              - |
                test_pane_title "generate and fire io-document cloudevent"
                cat<<EOF | jq | tee io_document.json | nats -s "${NATS_URL}" pub "${MINDWM_BACK_NATS_SUBJECT_PREFIX}.iodocument"
                {                                                                                         
                  "specversion": "1.0",
                  "type": "iodocument",
                  "source": "${MINDWM_BACK_NATS_SUBJECT_PREFIX}",
                  "subject": "${MINDWM_BACK_NATS_SUBJECT_PREFIX}",
                  "id": "`uuidgen`",
                  "datacontenttype": "application/json",
                  "knativebrokerttl": 255,
                  "data": {
                    "iodocument": {                                                                                                                                                                     
                      "ps1": "${MINDWM_E2E_PS1}",
                      "input": "${MINDWM_E2E_INPUT_CMD}",
                      "output": "${MINDWM_E2E_EXPECTED_OUTPUT}",                                                                                              
                      "full_cmd": "${MINDWM_E2E_INPUT_CMD}"                                                                  
                    }                               
                  }
                }       
                EOF
                test_pane_title "OK"
      - window_name: nats
        layout: main-horizontal
        panes:
          - shell_command:
              - |
                wait_for_state "TEST: prepare_env: OK"
              - |
                test_pane_title "run nats"
                nats -s ${NATS_URL} sub -r ${MINDWM_BACK_NATS_SUBJECT_PREFIX}.iodocument --count 1 | tee nats_message.json
              - | 
                test_pane_title "test ps1"
                test "`cat nats_message.json | jq -r '.data.iodocument.ps1'`" == "${MINDWM_E2E_PS1}"
                test_pane_title "test input"
                test "`cat nats_message.json | jq -r '.data.iodocument.input'`" == "${MINDWM_E2E_INPUT_CMD}"
                test_pane_title "test output"
                test "`cat nats_message.json | jq -r '.data.iodocument.output'`" == "${MINDWM_E2E_EXPECTED_OUTPUT}"
                test_pane_title "OK"

      - window_name: io-context-knative-func
        layout: main-horizontal
        panes:
          - shell_command:
              - |
                wait_for_state "TEST: nats: OK"
              - |
                test_pane_title "waiting for io context knative function"
                while :; do
                  kubectl -n context-${CONTEXT_NAME} get pod -l serving.knative.dev/service=io-context | grep -i io-context || {
                    echo -n . 
                    sleep 1
                    continue
                  } 
                  break
                done
              - | 
                test_pane_title "waiting for io context knative function is ready"
                kubectl -n context-${CONTEXT_NAME} wait --for=condition=Ready pod --timeout=180s -l serving.knative.dev/service=io-context
              - | 
                test_pane_title "OK"

      - window_name: neo4j-iodocument 
        layout: main-horizontal
        panes:
          - shell_command:
              - |
                wait_for_state "TEST: io-context-knative-func: OK"
              - |
                test_pane_title "run query"
                echo "MATCH (n:IoDocument)
                WHERE n.output = '${MINDWM_E2E_EXPECTED_OUTPUT}' AND n.user_input = '${MINDWM_E2E_INPUT_CMD}' AND n.ps1 = '${MINDWM_E2E_PS1}'
                RETURN COUNT(n) AS node_count;" | /usr/local/cypher-shell/bin/cypher-shell -a bolt://${CONTEXT_NAME}-neo4j.context-${CONTEXT_NAME}:7687 -u ${NEO4J_USERNAME} -p ${NEO4J_PASSWORD} --format plain --non-interactive | tail -n1 | grep "^1$"
              - | 
                test_pane_title "OK"

      - window_name: context-broker
        layout: main-horizontal
        panes:
          - shell_command:
              - |
                wait_for_state "TEST: nats: OK"
              - |
                test_pane_title "waiting for event display pod"
                while :; do
                  kubectl -n context-${CONTEXT_NAME} get pod -l serving.knative.dev/service=event-display-mindwm-e2e-test | grep -i event-display || {
                    echo -n . 
                    sleep 1
                    continue
                  } 
                  break
                done
              - |
                test_pane_title "waiting for event-display is ready"
                kubectl -n context-${CONTEXT_NAME} wait --for=condition=Ready pod --timeout=180s -l serving.knative.dev/service=event-display-mindwm-e2e-test
              - |
                test_pane_title "capture logs"
                # kubectl -n context-${CONTEXT_NAME} logs -f -l serving.knative.dev/service=event-display-mindwm-e2e-test | awk '{if ($0 !~ ".*cloudevents.Event$") {printf("%s ", $0) } else { print }} END { print }' | tee /tmp/cloudevent.log
                POD_NAME=`kubectl -n context-${CONTEXT_NAME} get pods -l serving.knative.dev/service=event-display-mindwm-e2e-test --field-selector=status.phase=Running -o custom-columns=POD_NAME:.metadata.name --no-headers`
                # kubectl -n context-${CONTEXT_NAME} logs -f --since=0 ${POD_NAME} | awk '{if ($0 !~ ".*cloudevents.Event$") {printf("%s ", $0) } else { print }} END { print }' | tee /tmp/cloudevent.log
                kubectl -n context-${CONTEXT_NAME} logs -f --since=0 ${POD_NAME} | awk '{if ($0 !~ ".*cloudevents.Event$") {printf("%s ", $0) } else { print }} END { print }' | tee /tmp/cloudevent.log
              - | 
                grep 'type: created.*source: graph.node.*subject: IoDocument' /tmp/cloudevent.log | sed 's/.*Data,   //;s/ } ..  cloudevents.Event$/}/' > /tmp/iodocument.json
              - | 
                test_pane_title "iodocument test ps1"
                test "`cat /tmp/iodocument.json | jq -r '.payload.after.properties.ps1'`" == "${MINDWM_E2E_PS1}"
                test_pane_title "iodocument test input"
                test "`cat /tmp/iodocument.json | jq -r '.payload.after.properties.user_input'`" == "${MINDWM_E2E_INPUT_CMD}"
                test_pane_title "iodocument test output"
                test "`cat /tmp/iodocument.json | jq -r '.payload.after.properties.output'`" == "${MINDWM_E2E_EXPECTED_OUTPUT}"
                test_pane_title "OK"


      - window_name: test-guard
        layout: main-horizontal
        panes:
          - shell_command:
              - | 
                set +e
                trap -p
                trap - ERR
                sleep 10
              - |
                pane_title "test guard"
                cat<<'EOF' | tee watch.sh
                MAX_TIMEOUT=350
                START="`date +%s`"

                dump_state() {
                        tmux list-panes -a -F '#{pane_title}'
                } 

                while :; do 
                        dump_state > new_state.txt
                        running=`expr $(date +%s) - $START` 
                        diff -Nur state.txt new_state.txt || {
                                # State change event
                                diff -Nur state.txt new_state.txt | grep 'TEST:.* FAIL$' && {
                                        echo "TEST FAIL"
                                        exit 1
                                }
                                awk '/^TEST:.*/ { 
                                        if ($0 !~ /^TEST:.* OK/) {
                                                exit 1
                                        }
                                }' new_state.txt && {
                                        echo "ALL TESTS PASSED"
                                        exit 0 
                                }
                        }
                        mv new_state.txt state.txt
                        if [ $running -ge $MAX_TIMEOUT ] ; then
                                echo "TIMEOUT"
                                exit 2
                        fi
                        sleep 1

                done
                EOF
                bash ./watch.sh
                sleep 10
                echo $? > /tmp/_result.txt
                test_pane_title cleanup
                kubectl delete -f ./resources.yaml
                mv /tmp/_result.txt /tmp/result.txt
            

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cluster-admin-sa
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cluster-admin-sa-binding
subjects:
- kind: ServiceAccount
  name: cluster-admin-sa
  namespace: default
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: mindwm-e2e
  namespace: default
  labels:
    app: mindwm-e2e
spec:
  template:
    metadata:
      labels:
        app: mindwm-e2e
    spec:
      serviceAccountName: cluster-admin-sa
      containers:
      - name: mindwm-e2e
        image: ghcr.io/mindwm/mindwm-image/mindwm-image:mindwm-client
        command: ["/bin/sh", "-c"]
        args: 
          - |
            export MINDWM_UUID=`uuidgen`;
            tmuxp load -d ~/.tmuxp/entrypoint.yaml;
            sleep 3;
            ttyd -W -p80 tmux attach &
            while :; do
                echo .
                test -f /tmp/result.txt && exit `cat /tmp/result.txt`
                sleep 1
            done
        env:
          - name: CONTEXT_NAME
            value: "team-a"
          - name: NEO4J_USERNAME
            value: "neo4j"
          - name: NEO4J_PASSWORD
            value: password
        volumeMounts:
          - mountPath: /root/.tmuxp/
            name: config-volume
        ports:
          - containerPort: 80
            name: ttyd
      volumes:
        - name: config-volume
          configMap:
            name: mindwm-e2e-config
      restartPolicy: OnFailure
#apiVersion: v1
#kind: Pod
#metadata:
#  name: mindwm-e2e
#  namespace: default
#  labels:
#    app: mindwm-e2e
#spec:
#  serviceAccountName: cluster-admin-sa
#  containers:
#  - name: mindwme-e2e
#    image: ghcr.io/mindwm/mindwm-image/mindwm-image:mindwm-client
#    env:
#      - name: CONTEXT_NAME
#        value: "team-a"
#      - name: NEO4J_USERNAME
#        value: "neo4j"
#      - name: NEO4J_PASSWORD
#        value: password
#    # imagePullPolicy: Always
#    volumeMounts:
#      - mountPath: /root/.tmuxp/
#        name: config-volume
#    ports:
#      - containerPort: 80
#        name: ttyd
#  volumes:
#    - name: config-volume
#      configMap:
#        name: mindwm-e2e-config

---
apiVersion: v1
kind: Service
metadata:
  name: mindwm-e2e-service
  namespace: default
spec:
  selector:
    app: mindwm-e2e
  ports:
    - port: 80
      name: ttyd
      nodePort: 30112
  type: LoadBalancer



#- shell_command:
#- |
#watch nats -s ${NATS_URL} stream ls
